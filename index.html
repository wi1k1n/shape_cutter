<DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Shape Cutter</title>
	<script type="text/javascript" src="js/paper-full.js"></script>
	<style type="text/css">
		html, body, #cnv_editor {
			width: 100%;
			height: 100%;
			margin: 0;
		}
		canvas[resize] {
			width: 100%;
			height: 100%;
		}
	.info {
		position: absolute;
		background-color: rgba(174, 255, 255, 0.6);
		padding: 2px 5px;
		border: 1px solid black;
	}
	.info-mouse {
		right: 0px;
		top: 0px;
		text-align: right;
	}
	</style>
</head>
<body>
<input type="file" id="inp_file" style="display: none;" accept=".jpg, .jpeg, .png, .bmp">
<div id="div_canvas">
    <canvas id="cnv_editor" resize>HTML5 Canvas is not supported in your browser</canvas>
</div>
<div id="divMousePos" class="info info-mouse"></div>
<script type="text/javascript" src="js/constants.js"></script>
<script type="text/javascript" src="js/sdk.js"></script>
<script type="text/javascript">
(function() {
	let cnv = document.getElementById('cnv_editor');
	let divMouse = document.getElementById('divMousePos');
	paper.install(window);
	paper.setup(cnv);
	// project.clear();
	project.activeLayer.position = view.center;
	project.activeLayer.applyMatrix = false;

	let appMode = APPMODE.CREATE_SHAPES;
	const navigationAllowed = appMode == APPMODE.CREATE_SHAPES
		 || appMode == APPMODE.DRAW_CUTLINE

	// let layers = {};
	let shapes = [];
	let pathInput = false;
	let moveShapes = false; // flag, if moving shapes currently

	let cutLines = [];
	let cutLineInput = false;

	let bgImg = new Raster({
		source: IMG_PLACEHOLDER,
		position: view.center,
		smoothing: 'off'
	}).sendToBack();



	function switchAppMode(mode) {
		if (appMode == mode) {
			return;
		}
		appMode = mode;
		
		function cleanAllLeftoversFor(mode) {
			if (mode != APPMODE.CREATE_SHAPES) {
				// toggleMoveShapesMode(false);
				cancelCurrentShapeCreation();
			} else if (mode != APPMODE.DRAW_CUTLINE) {
				cancelCurrentCutlineCreation();
			}
		}

		cleanAllLeftoversFor(mode);
		if (mode == APPMODE.CREATE_SHAPES) {
			// cutLines.forEach(l => {
			// 	l.visible = false;
			// 	l.locked = true;
			// });
		} else if (mode == APPMODE.DRAW_CUTLINE) {
			// cutLines.forEach(l => {
			// 	l.visible = true;
			// 	l.locked = false;
			// });
		}
	}

	function moveShapesGetSelectedShape() {
		return shapes.filter(p => p.selected).at(0);
	}
	function onMouseWheel(evt) {
		// console.log(evt);
		const mousePoint = new Point(evt.x, evt.y);
		let mWheelOverloaded = false;
		if (appMode == APPMODE.CREATE_SHAPES) {
			if (moveShapes) {
				if (evt.altKey) {
					mWheelOverloaded = true;
					let sShape = moveShapesGetSelectedShape();
					if (sShape) {
						if (evt.shiftKey) {
							sShape.rotate(SHAPE_ROTATE_SPEED * Math.sign(evt.deltaY), mousePoint);
						} else {
							sShape.rotate(SHAPE_ROTATE_SPEED * Math.sign(evt.deltaY));
						}
					}
				}
			}
		}
		if (appMode == APPMODE.CREATE_SHAPES
		 || appMode == APPMODE.DRAW_CUTLINE) {
			if (!mWheelOverloaded) {
				let scaleFactor = Math.pow(SCALE_MULTIPLIER, -Math.sign(evt.deltaY));
				if (evt.shiftKey) {
					project.activeLayer.scale(scaleFactor);
				} else {
					project.activeLayer.scale(scaleFactor, mousePoint);
				}
			}
		}
	}
	function onMouseClick(evt) {
	}
	function onMouseDown(evt) {
		// console.log(evt);
		let curPoint = project.activeLayer.matrix.inverseTransform(evt.point);
		// let curPoint = view.getEventPoint(evt.event);
		if (appMode == APPMODE.CREATE_SHAPES) {
			if (evt.event.buttons & MOUSE.LEFT) {
				if (!moveShapes) {
					if (pathInput) {
						let path = shapes.at(-1);
						path.add(curPoint);
					} else {
						let path = new Path({
							segments: [curPoint, curPoint],
							fillColor: 'rgba(255, 255, 255, 0.00001)',
							strokeColor: 'red',
							strokeWidth: 2,
							closed: true,
							locked: false,
							applyMatrix: false,
							onMouseEnter: shapeOnMouseEnter,
							onMouseLeave: shapeOnMouseLeave,
							onMouseDrag: shapeOnMouseDrag,
							onMouseMove: shapeOnMouseMove
						});
						shapes.push(path);
						pathInput = true;
					}
				}
			}
		} else if (appMode == APPMODE.DRAW_CUTLINE) {
			if (evt.event.buttons & MOUSE.LEFT) {
				if (!cutLineInput) {
					let path = new Path({
						segments: [curPoint, curPoint],
						fillColor: 'rgba(255, 255, 255, 0.00001)',
						strokeColor: 'orange',
						strokeWidth: 2,
						applyMatrix: false,
					});
					cutLines.push(path);
					cutLineInput = true;
				}
			}
		}
	}
	function onMouseMove(evt) {
		let mpoint = project.activeLayer.matrix.inverseTransform(evt.point);
		// let mpoint = view.getEventPoint(evt.event);
		divMouse.innerHTML = mpoint.toString();
		if (appMode == APPMODE.CREATE_SHAPES) {
			if (pathInput && shapes.length) {
				let path = shapes.at(-1);
				path.lastSegment.point = mpoint;
			}
		} else if (appMode == APPMODE.DRAW_CUTLINE) {
			if (cutLineInput && cutLines.length) {
				let line = cutLines.at(-1);
				line.lastSegment.point = mpoint;
			}
		}
	}
	function onMouseUp(evt) {
		function MUP(c) { return Math.floor(Math.log2(c)); }
		// !!! evt.event.buttons property doesn't contain the button that triggered an event. Use evt.event.button insted !!!
		let mpoint = project.activeLayer.matrix.inverseTransform(evt.point);
		// let mpoint = view.getEventPoint(evt.event);
		if (appMode == APPMODE.DRAW_CUTLINE) {
			if (evt.event.button == MUP(MOUSE.LEFT)) {
				cutLineInput = false;
			}
		}
	}
	function onMouseDrag(evt) {
		onMouseMove(evt);
		// console.log(evt);
		if (appMode == APPMODE.CREATE_SHAPES
		 || appMode == APPMODE.DRAW_CUTLINE) {
			if (evt.event.buttons & MOUSE.RIGHT) {
				project.activeLayer.translate(evt.delta);
			}
		}
	}
	function onKeyDown(evt) {
		// console.log(evt.event.code);
		// console.log(evt);
		if (appMode == APPMODE.CREATE_SHAPES) {
			switch (evt.event.code) {
				case KEYBOARD.O: {
					if (evt.modifiers.control) { // Ctrl+O
						preventDefaultEvents(evt.event);
						showOpenFileDialog();
					} else { // O
						project.activeLayer.position = view.center;
					}
					break;
				}
				case KEYBOARD.SPACE: {
					if (evt.modifiers.control) { // Ctrl+Space
						project.activeLayer.fitBounds(view.bounds);
					} else { // Space
						project.activeLayer.scaling = new Point(1, 1);
						project.activeLayer.position = view.center;
						// project.activeLayer.position = new Point();
					}
					break;
				}
				case KEYBOARD.ESCAPE: {
					cancelCurrentShapeCreation();
					break;
				}
				case KEYBOARD.C: {
					shapes.forEach(p => p.remove());
					shapes = [];
					pathInput = false;
					toggleMoveShapesMode(false);
					break;
				}
				case KEYBOARD.M: {
					if (shapes.length) {
						toggleMoveShapesMode();
					}
					break;
				}
				case KEYBOARD.R: {
					if (moveShapes) {
						if (evt.modifiers.alt) {
							let sShape = moveShapesGetSelectedShape();
							if (sShape) {
								sShape.rotation = 0;
							}
						}
					}
					break;
				}
				case KEYBOARD.DELETE: {
					if (moveShapes) {
						let removedIds = shapes.map((p, i) => [p, i]).filter(t => t[0].selected).map(t => {
							t[0].remove();
							return t[1];
						});
						shapes = shapes.filter((p, i) => !removedIds.includes(i));
						if (!shapes.length) {
							toggleMoveShapesMode(false);
						}
					}
					break;
				}
				default: {
					break;
				}
			}
		}
		if (appMode == APPMODE.DRAW_CUTLINE) {
			switch(evt.event.code) {
				case KEYBOARD.ESCAPE: {
					cancelCurrentCutlineCreation();
					break;
				}
				case KEYBOARD.C: {
					cutLines.forEach(l => l.remove());
					cutLines = [];
					cutLineInput = false;
					break;
				}
				case KEYBOARD.S: {
					let p = shapes[0].divide(cutLines[0]);
					p.fillColor = 'rgba(255, 0, 0, 1)';
				}
				default: {
					break;
				}
			}
		}
		// Common for all app modes
		switch (evt.event.code) {
			case KEYBOARD.B: {
				bgImg.visible = !bgImg.visible;
				break;
			}
			case KEYBOARD.ONE: {
				switchAppMode(APPMODE.CREATE_SHAPES);
				break;
			}
			case KEYBOARD.TWO: {
				switchAppMode(APPMODE.DRAW_CUTLINE);
				break;
			}
			default: break;
		}
	}

	// EventListeners
	paper.view.onClick = onMouseClick;
	paper.view.onMouseDown = onMouseDown;
	paper.view.onMouseMove = onMouseMove;
	paper.view.onMouseUp = onMouseUp;
	paper.view.onMouseDrag = onMouseDrag;
	paper.view.onKeyDown = onKeyDown;
	cnv.addEventListener('wheel', onMouseWheel);
	window.addEventListener("paste", onImagePaste, false);
	document.oncontextmenu = preventDefaultEvents;
	cnv.oncontextmenu = preventDefaultEvents;
	document.getElementById('inp_file').onchange = inp_fileOnChange;  // open new file
	
	

	function shapeOnMouseEnter(evt) {
		if (!moveShapes || appMode != APPMODE.CREATE_SHAPES) {
			evt.target.selected = false;
			return;
		}
		evt.target.selected = true;
	}
	function shapeOnMouseMove(evt) {
		shapeOnMouseEnter(evt);
	}
	function shapeOnMouseLeave(evt) {
		if (!moveShapes || appMode != APPMODE.CREATE_SHAPES) {
			evt.target.selected = false;
			return;
		}
		evt.target.selected = false;
	}
	function shapeOnMouseDrag(evt) {
		if (!moveShapes || appMode != APPMODE.CREATE_SHAPES) {
			evt.target.selected = false;
			return;
		}
		if (evt.event.buttons & MOUSE.LEFT) {
			evt.target.selected = true;
			evt.target.translate(evt.delta.divide(project.activeLayer.scaling));
		}
	}


	function cancelCurrentShapeCreation() {
		let path = shapes.at(-1); // can be undefined
		if (!pathInput) {
			return;
		}
		if (path && path.segments.length > 3) {
			path.removeSegment(path.segments.length - 1);
		} else {
			if (shapes.length) {
				path.remove();
				shapes.pop();
			}
		}
		pathInput = false;
	}
	function cancelCurrentCutlineCreation() {
		if (!cutLineInput) {
			return;
		}
		if (cutLines.length) {
			cutLines.at(-1).remove();
			cutLines.pop();
		}
		cutLineInput = false;
	}
	function toggleMoveShapesMode(enable=null) {
		if (enable === null) {
			enable = !moveShapes;
		}
		moveShapes = enable;
		cancelCurrentShapeCreation();
		// shapes.forEach(p => {
		// 	p.selected = false;
		// 	p.locked = !moveShapes;
		// });
	}
	





	function showOpenFileDialog() {
		document.getElementById('inp_file').click();
	}
	function inp_fileOnChange(e) {
		if (!e.target.files || !e.target.files.length) return;
		bgImg.source = URL.createObjectURL(e.target.files[0]);
	}
	function onImagePaste(evt) { // triggers when user pastes image from clipboard
		// console.log(evt.clipboardData.getData('image/png'));
		navigator.clipboard.read().then(cis => {
			for (const ci of cis) {
				// console.log(ci);
				for (const type of ci.types) {
					if (!IMG_PASTE_MIME_TYPES.includes(type)) continue;
					// console.log('Trying type ', type);
					ci.getType(type).then(x => {
						// console.log('Got: ', x);
						bgImg.source = URL.createObjectURL(x);
					}).catch(e => console.log('getType() => ', e));
					break;
				}
			}
		}).catch(e => console.log('read() =>', e));
	}
	function preventDefaultEvents(evt) {
		if (evt.preventDefault != undefined)
			evt.preventDefault();
		if (evt.stopPropagation != undefined)
			evt.stopPropagation();
	}
})();
</script>
</body>
</html>