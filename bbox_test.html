<DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Bezier</title>
	<style type="text/css">
		html, body {
			width: 100%;
			height: 100%;
			margin: 0;
		}
	</style>
</head>
<body>
<div id="result">
</div>
<script type="text/javascript">
	const STYLE_SHAPE = {c: 'lightgray', w: 1, t: 'connected'}; // t: connected/points
	const ROTATE_SPEED = 0.05;
	const SIMULATE_ANGLE_STEP = 0.01;
	const SHAPE_SCALE = 100;
	const EPS = 1e-5;

	// must be defined in a sequential order!
	// const PTS = [[0, 0], [134.75, 0], [134.75, 269.5], [0, 217.69]];
	// const PTS = [[0, 0], [-1, 0], [-2, 1], [-3, 0], [-4, 2], [0, 2]].map(x => scale(SHAPE_SCALE, x));
	const PTS = [[0, 0], [-1, 0], [-2, 1], [-3, 0], [-5, -1], [-6, 0], [-5, 1], [-4, 0], [-3.5, 0.2], [-5, 2], [0, 2]].map(x => scale(SHAPE_SCALE, x));
	let pts = PTS.slice();

	const cnv = document.createElement('canvas');
	cnv.width = window.innerWidth;
	cnv.height = window.innerHeight;
	document.getElementById('result').appendChild(cnv);
	const ctx = cnv.getContext('2d');
	ctx.translate(0, cnv.height);
	ctx.scale(1, -1);

	let centerMass = getShapeCM(pts);
	let CNV_CENTER = [cnv.width / 2, cnv.height / 2];

	console.log('Shape: ', pts);

	// interactBestFit();
	redraw();



	document.addEventListener('wheel', (e) => {
		rotateShape(pts, Math.sign(event.deltaY) * ROTATE_SPEED);
		redraw();
		let [left, right, top, bottom] = getBBOX(pts);
		console.log('Max', Math.max(right - left, bottom - top).toFixed(2), '(' + (right - left).toFixed(2) + '; ' + (bottom - top).toFixed(2) + ')');
	});
	document.addEventListener('keydown', function(e) { });
	document.addEventListener('keyup', function(e) {
		let key = e.key.toLowerCase();
		if (key == 'c') {
			let shape = pts.slice();
			calculateBestCut(shape);
		} else if (key == 'b') {
			interactBestFit();
		} else if (key == 'r') {
			pts = PTS.slice();
			rotateShape(pts, 0);
			redraw();
		} else if (key == 'g') {
			const shape = generateShape(10);
			centerMass = getShapeCM(shape);
			pts = shape;
			redraw();
		}
	});
	document.addEventListener('mousemove', function(e) { e = e || window.event; });

	function interactBestFit() {
		let [bestAng, bestVal] = simulateShapeFit(pts);
		console.log('Best rotation: ' + (bestAng * 180 / Math.PI).toFixed(1) + ' with value: ' + bestVal.toFixed(2));
		rotateShape(pts, bestAng);
		redraw();
	}

	function generateShape(vN, w=500, h=500) {
		// https://gist.github.com/Azeirah/75d44a6803b88e37ea8703a040e89353
		// https://stackoverflow.com/a/20623817
		// https://stackoverflow.com/a/64459159
		// http://www.cccg.ca/proceedings/1996/cccg1996_0007.pdf
		// https://www.youtube.com/watch?v=QLKBQU05NSk

		// first generate random points
		let shape = [];
		for (let i = 0; i < vN; ++i) {
			shape.push([Math.random() * w - w / 2, Math.random() * h - h / 2]);
		}

		// get line from left-most to right-most points
		const getLeftRightMostPoints = function(shape) {
			let lm = shape[0], rm = shape[0];
			for (let i = 1; i < shape.length; ++i) {
				const p = shape[i];
				if (p[0] < lm[0] || (Math.abs(lm[0] - p[0]) < EPS && p[1] < lm[1]))
					lm = p;
				if (p[0] > rm[0] || (Math.abs(rm[0] - p[0]) < EPS && p[1] < rm[1]))
					rm = p;
			}
			return [lm, rm];
		};
		const [lm, rm] = getLeftRightMostPoints(shape);
		const line = [lm, rm];

		// order points for below/on/above the line
		let A = [], B = [], C = [];
		for (let i = 0; i < shape.length; ++i) {
			const p = shape[i];
			const sign = isPointAboveTheLine(p, line);
			(sign < 0 ? A : (sign > 0 ? B : C)).push(p);
		}

		// sort points and merge the arrays
		let AC = A.concat(C);
		const getSortXFunc = (m) => {
			return (f, s) => {
				return m * (f[0] - s[0]);
			};
		};
		AC = AC.sort(getSortXFunc(1));
		B = B.sort(getSortXFunc(-1));
		return AC.concat(B);
	}

	function cutShapeWithLine(shape, line) {
		let shapeClosed = shape.slice();
		shapeClosed.push(shape[0]);

		// intersect cutting line with all the edges
		let intersections = [];
		let intsProjs = []; // intersection projections
		const v0 = subtract(line[1], line[0]);
		for (let i = 0; i < shapeClosed.length - 1; i++) {
			const edge = [shapeClosed[i], shapeClosed[i + 1]];
			const [p, onEdge,] = intersectLines(edge[0], edge[1], line[0], line[1]);
			if (onEdge) {
				intersections.push({p: p, edge: i});
				intsProjs.push(dot(v0, subtract(p, line[0])));
			}
		}
		// sort intersections along the line
		intersections = intersections.map((x, i) => [x, i]).sort((f, s) => intsProjs[f[1]] > intsProjs[s[1]] ? 1 : (intsProjs[f[1]] < intsProjs[s[1]] ? -1 : 0)).map(x => x[0]);

		// follow edges
		let shapes = [[]];
		const intersectionIndices = intersections.map(x => x.edge);
		let curInd = 0;
		for (let i = 0; i < shapeClosed.length - 1; i++) {
			const edge = [shape[i], shape[i + 1]];
			// add first point of current edge
			// 'new' is the one, created out of intersection, index of point on line ordered along the line is used in this case
			shapes[curInd].push({p: edge[0], i: i, new: false});
			const intInd = intersectionIndices.findIndex(x => x == i);
			if (intInd > -1) { // current edge is intersected
				const intersection = intersections[intInd];

				// add intersection point to current shape
				shapes[curInd].push({p: intersection.p, i: intInd, new: true});
				
				const iIndsOnlyNews = shapes[curInd].filter(x => x.new);
				if (iIndsOnlyNews.length < 2 // we've just started
					|| Math.abs(iIndsOnlyNews.at(0).i - iIndsOnlyNews.at(-1).i) > 1 // points on line r not adjacent
					|| Math.min(iIndsOnlyNews.at(0).i, iIndsOnlyNews.at(-1).i) % 2) { // interval on line is ouside of main shape
					// step into a new shape
					curInd++;
					if (curInd >= shapes.length)
						shapes.push([]);
					shapes[curInd].push({p: intersection.p, i: intInd, new: true});
				} else {
					// step out of current shape
					curInd--;
					shapes[curInd].push({p: intersection.p, i: intInd, new: true});
				}
			}
		}

		return shapes.map(sh => sh.map(x => x.p));
	}

	function calculateBestCut(shape) {
		// first define cutting line
		const [left, right, top, bottom] = getBBOX(shape);
		// const p0 = [Math.random() * (right - left) + left, Math.random() * (bottom - top) + top];
		const p0 = scale(SHAPE_SCALE, [1, 0.5]);
		const ang0 = Math.random() * Math.PI;
		const v0 = [Math.cos(ang0), Math.sin(ang0)];
		// const p1 = [p0[0] + v0[0], p0[1] + v0[1]];
		const p1 = scale(SHAPE_SCALE, [-7, 0.5]);

		ctx.save();
		ctx.translate(CNV_CENTER[0] - centerMass[0], CNV_CENTER[1] - centerMass[1]);
		drawLine(p0, p1, 'blue');
		ctx.restore();

		shapes = cutShapeWithLine(shape, [p0, p1]);

		console.log(shapes);
		shapes.forEach(sh => drawShape(sh, {c: getRandomColor(), w: 5, t: 'connected'}, false));
	}

	function simulateShapeFit(shape) {
		let shapeClone = shape.slice();
		// Test all rotations
		let bestFitAngle = 0, bestFitVal = Number.MAX_VALUE;
		for (let i = 0; i < Math.PI; i += SIMULATE_ANGLE_STEP) {
			let [left, right, top, bottom] = getBBOX(shapeClone);
			if (Math.max(right - left, bottom - top) < bestFitVal) {
				bestFitVal = Math.max(right - left, bottom - top);
				bestFitAngle = i;
			}
			rotateShape(shapeClone, SIMULATE_ANGLE_STEP, true);
		}
		return [bestFitAngle, bestFitVal];
	}

	function rotateShape(shape, ang, noCMCalc = false) {
		let s = Math.sin(ang);
		let c = Math.cos(ang);

		for (let i = 0; i < shape.length; i++) {
			let x = shape[i][0], y = shape[i][1];
			shape[i] = [x * c - y * s, x * s + y * c];
		}

		if (!noCMCalc)
			centerMass = getShapeCM(shape);
	}

	function redraw() {
		ctx.clearRect(0, 0, cnv.width, cnv.height);

		drawShape(pts, STYLE_SHAPE); // shape
		const [l, r, t, b] = getBBOX(pts);
		drawShape([[l, t], [l, b], [r, b], [r, t]], {c: 'red', w: 1, t: 'connected'}); // bbox
		const PTS_STYLE = {c: 'gradient', w: 5, t: 'points'};
		drawPolygon(pts, PTS_STYLE);
	}

	function drawLine(from, to, style, width) {
		ctx.save();

		ctx.beginPath();
		ctx.moveTo(from[0], from[1]);
		ctx.lineTo(to[0], to[1]);
		if (style)
			ctx.strokeStyle = style;
		if (width)
			ctx.lineWidth = width;
		ctx.stroke()

		ctx.restore();
	}
	function drawShape(shape, style=STYLE_SHAPE) {
		return drawPolygon(shape.concat([shape[0]]), style);
	}
	function drawPolygon(shape, style=STYLE_SHAPE) {
		if (shape.length < 1 || shape.includes(undefined))
			return;
		ctx.save();
		ctx.translate(CNV_CENTER[0] - centerMass[0], CNV_CENTER[1] - centerMass[1]);
		let clr = Array(shape.length).fill(style.c);
		if (style.c == 'gradient') {
			for (let i = 0; i < shape.length; ++i) {
				clr[i] = 'hsl(' + (i * 255 / shape.length) + ',100%,50%)';
			}
		}
		if (style.t == 'connected') {
			ctx.lineWidth = style.w;
			for (let i = 0; i < shape.length - 1; ++i) {
				ctx.beginPath();
				ctx.moveTo(shape[i][0], shape[i][1]);
				ctx.lineTo(shape[i + 1][0], shape[i + 1][1]);
				ctx.strokeStyle = clr[i];
			ctx.stroke();
			}
		} else {
			for (let i = 0; i < shape.length; ++i) {
				ctx.beginPath();
				ctx.arc(shape[i][0], shape[i][1], style.w, 0, 2 * Math.PI);
				ctx.fillStyle = clr[i];
				ctx.fill();
			}
		}
		ctx.restore();
	}

	function intersectLines(a1, a2, b1, b2) {
		// intersect line a with line b; a1, a2 - points on line a; b1, b2 - points on line b
		// returns point of intersection and booleans saying if intersection point lies inside of provided intervals
		const denom = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
		if (Math.abs(denom) < EPS) {
			return [null, false, false];
		}
		const ua = ((b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0])) / denom;
		const ub = ((a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0])) / denom;
		return [[a1[0] + ua * (a2[0] - a1[0]), a1[1] + ua * (a2[1] - a1[1])],
				ua >= 0 && ua <= 1,
				ub >= 0 && ub <= 1];
	}
	function isPointAboveTheLine(p, line) {
		const p1 = line[0], p2 = line[1];
		const det = (p1[0] - p[0]) * (p2[1] - p[1]) - (p2[0] - p[0]) * (p1[1] - p[1]);
		return Math.sign(det);
	}
	
	function dot(v1, v2) {
		return v1[0] * v2[0] + v1[1] * v2[1];
	}
	function cross(v1, v2) {
		return [0, 0, v1[0] * v2[1] - v1[1] * v2[0]];
	}
	function add(p1, p2) {
		return [p1[0] + p2[0], p1[1] + p2[1]];
	}
	function subtract(p1, p2) {
		return add(p1, negate(p2));
	}
	function multiply(p1, p2) {
		return [p1[0] * p2[0], p1[1] * p2[1]];
	}
	function scale(v, p) {
		return [v * p[0], v * p[1]];
	}
	function divide(p1, p2) {
		return [p1[0] / p2[0], p1[1] / p2[1]];
	}
	function negate(p) {
		return [-p[0], -p[1]];
	}
	function norm(v) {
		return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	}
	function norm2(v) {
		return v[0] * v[0] + v[1] * v[1];
	}
	function dst(p1, p2) {
		return norm(subtract(p2, p1));
	}
	function dst2(p1, p2) {
		return norm2(subtract(p2, p1));
	}

	function getRandomColor() {
		const randomColor = Math.floor(Math.random()*16777215).toString(16);
		return '#' + randomColor;
	}
	function getBBOX(shape) {
		let left = Math.min.apply(null, shape.map(x => x[0]));
		let right = Math.max.apply(null, shape.map(x => x[0]));
		let top = Math.min.apply(null, shape.map(x => x[1]));
		let bottom = Math.max.apply(null, shape.map(x => x[1]));
		return [left, right, top, bottom];
	}
	function getShapeCM(shape) {
		return [shape.reduce((p, c) => p + c[0], 0) / shape.length,
				shape.reduce((p, c) => p + c[1], 0) / shape.length];
	}
</script>
</body>
</html>