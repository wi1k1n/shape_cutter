<DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<script src="sdk.js"></script>
	<title>Bezier</title>
	<style type="text/css">
		html, body {
			width: 100%;
			height: 100%;
			margin: 0;
		}
	</style>
</head>
<body>
<div id="result">
</div>
<script type="text/javascript">
	const STYLE_SHAPE = new CtxStyle('lightgray', 1, 'connected');
	const STYLE_BBOX = new CtxStyle('red', 1, 'connected');
	const STYLE_POINTS = new CtxStyle('gradient', 5, 'points');
	const ROTATE_SPEED = 0.05;
	const SIMULATE_ANGLE_STEP = 0.01;
	const SHAPE_SCALE = 200;
	const EPS = 1e-5;

	// must be defined in a sequential order!
	// const PTS = [[0, 0], [134.75, 0], [134.75, 269.5], [0, 217.69]];
	// const PTS = [[0, 0], [-1, 0], [-2, 1], [-3, 0], [-4, 2], [0, 2]].map(x => scale(SHAPE_SCALE, x));
	// const PTS = [[0, 0], [-1, 0], [-2, 1], [-3, 0], [-5, -1], [-6, 0], [-5, 1], [-4, 0], [-3.5, 0.2], [-5, 2], [0, 2]].map(x => scale(SHAPE_SCALE, x));
	function generatePTS() {
		let dir = [0, 1];
		let r = 1;
		let curPoint = [0, 0];
		let shape = [];
		let n = [0, 0, 1];
		for (let i = 0; i < 5; ++i) {
			let r = normalize(cross(dir.concat([0]), n).splice(0, 2));
			let c = scale(.5, r);
			shape.push(add(curPoint, c));
			shape.splice(0, 0, add(curPoint, negate(c)));
			curPoint = add(curPoint, dir);
			dir = scale(Math.floor(i / 2) + 2, r);
		}
		return shape;
	}
	// const PTS = generatePTS();
	const PTS = [[1, 0], [1, 1], [-1, 1], [-1, 0.3], [-0.5, 0.5], [0, 0.2]].map(x => scale(SHAPE_SCALE, x));
	let pts = PTS.slice();
	let centerMass = getShapeCM(pts);
	const p0 = scale(SHAPE_SCALE, [1, 0.5]);
	const p1 = scale(SHAPE_SCALE, [-7, 0.5]);

	const cnv = document.createElement('canvas');
	cnv.width = window.innerWidth;
	cnv.height = window.innerHeight;
	document.getElementById('result').appendChild(cnv);
	const ctx = cnv.getContext('2d');
	ctx.translate(0, cnv.height);
	ctx.scale(1, -1);

	let CNV_CENTER = [cnv.width / 2, cnv.height / 2];

	console.log('Shape: ', pts);

	// interactBestFit();
	redraw();



	document.addEventListener('wheel', (e) => {
		rotateShape(pts, Math.sign(event.deltaY) * ROTATE_SPEED);
		redraw();
		let [left, right, top, bottom] = getBBOX(pts);
		console.log('Max', Math.max(right - left, bottom - top).toFixed(2), '(' + (right - left).toFixed(2) + '; ' + (bottom - top).toFixed(2) + ')');
	});
	document.addEventListener('keydown', function(e) { });
	document.addEventListener('keyup', function(e) {
		let key = e.key.toLowerCase();
		if (key == 'c') {
			let shape = pts.slice();
			calculateBestCut(shape);
		} else if (key == 'b') {
			interactBestFit();
		} else if (key == 'r') {
			if (e.shiftKey) { // Shift+R
				redraw();
			} else { // R
				pts = PTS.slice();
				rotateShape(pts, 0);
				redraw();
			}
		} else if (key == 'g') {
			const shape = generateShape(10);
			centerMass = getShapeCM(shape);
			pts = shape;
			redraw();
		} else if (key == 'l') {
			redraw();
			ctx.save();
			ctx.translate(CNV_CENTER[0] - centerMass[0], CNV_CENTER[1] - centerMass[1]);
			drawLine(p0, p1, 'blue');
			ctx.restore();
		}
	});
	document.addEventListener('mousemove', function(e) { e = e || window.event; });

	function interactBestFit() {
		let [bestAng, bestVal] = simulateShapeFit(pts);
		console.log('Best rotation: ' + (bestAng * 180 / Math.PI).toFixed(1) + ' with value: ' + bestVal.toFixed(2));
		rotateShape(pts, bestAng);
		redraw();
	}

	function generateShape(vN, w=500, h=500) {
		// https://gist.github.com/Azeirah/75d44a6803b88e37ea8703a040e89353
		// https://stackoverflow.com/a/20623817
		// https://stackoverflow.com/a/64459159
		// http://www.cccg.ca/proceedings/1996/cccg1996_0007.pdf
		// https://www.youtube.com/watch?v=QLKBQU05NSk

		// first generate random points
		let shape = [];
		for (let i = 0; i < vN; ++i) {
			shape.push([Math.random() * w - w / 2, Math.random() * h - h / 2]);
		}

		// get line from left-most to right-most points
		const getLeftRightMostPoints = function(shape) {
			let lm = shape[0], rm = shape[0];
			for (let i = 1; i < shape.length; ++i) {
				const p = shape[i];
				if (p[0] < lm[0] || (Math.abs(lm[0] - p[0]) < EPS && p[1] < lm[1]))
					lm = p;
				if (p[0] > rm[0] || (Math.abs(rm[0] - p[0]) < EPS && p[1] < rm[1]))
					rm = p;
			}
			return [lm, rm];
		};
		const [lm, rm] = getLeftRightMostPoints(shape);
		const line = [lm, rm];

		// order points for below/on/above the line
		let A = [], B = [], C = [];
		for (let i = 0; i < shape.length; ++i) {
			const p = shape[i];
			const sign = isPointAboveTheLine(p, line);
			(sign < 0 ? A : (sign > 0 ? B : C)).push(p);
		}

		// sort points and merge the arrays
		let AC = A.concat(C);
		const getSortXFunc = (m) => {
			return (f, s) => {
				return m * (f[0] - s[0]);
			};
		};
		AC = AC.sort(getSortXFunc(1));
		B = B.sort(getSortXFunc(-1));
		return AC.concat(B);
	}

	function cutShapeWithLine(shape, line) {
		let shapeClosed = shape.slice();
		shapeClosed.push(shape[0]);
		// let shapeClosed = [];

		// intersect cutting line with all the edges
		let intersections = [];
		let intsProjs = []; // intersection projections
		const v0 = subtract(line[1], line[0]);
		const v0r = scale(EPS, normalize([-v0[1], v0[0]])); // normal to v0 vector
		let hackedVertices = [];
		let hackedVerticesInds = [];
		for (let i = 0; i < shape.length; i++) {
			const edge = [shapeClosed[i], shapeClosed[i + 1]];
			let [p, onEdge,] = intersectLines(edge[0], edge[1], line[0], line[1]);
			if (onEdge) {
				// if the vertex coincide with the intersection point, move the vertex for an EPS little bit
				// such that it is not coinciding anymore and created just normal intersections
				// !!! this is hack, algorithm should be better designed for this to not happen!!!
				if (dst(edge[1], p) < EPS) { // edge[1] coincide with the intersection point
					// first try one side
					let newVertex = add(v0r, shapeClosed[i + 1]);
					[p, onEdge,] = intersectLines(edge[0], newVertex, line[0], line[1]);
					if (!onEdge) { // if no intersection is caused, trying another direction
						newVertex = add(negate(v0r), shapeClosed[i + 1]);
						[p, onEdge,] = intersectLines(edge[0], newVertex, line[0], line[1]);
						if (!onEdge)
							console.error('wtf, should never happen by definition');
					}
					hackedVertices.push(shapeClosed[i + 1]);
					hackedVerticesInds.push(i + 1);
					shapeClosed[i + 1] = newVertex;
					edge[1] = newVertex;
				}
				if (dst(edge[1], p) > EPS) {
					intersections.push({p: p, edge: i});
					intsProjs.push(dot(v0, subtract(p, line[0])));
				}
			}
		}
		// sort intersections along the line
		intersections = intersections.map((x, i) => [x, i]).sort((f, s) => intsProjs[f[1]] > intsProjs[s[1]] ? 1 : (intsProjs[f[1]] < intsProjs[s[1]] ? -1 : 0)).map(x => x[0]);

		// follow edges
		let shapes = [[]];
		const intersectionIndices = intersections.map(x => x.edge);
		let curInd = 0;
		const getRealPoint = function(ind) { // returns point of shape, or the real one, if current was hacked
			const hind = hackedVerticesInds.indexOf(ind);
			return hind > -1 ? hackedVertices[hind] : shapeClosed[ind];
		}
		for (let i = 0; i < shapeClosed.length - 1; i++) {
			const edge = [getRealPoint(i), getRealPoint(i + 1)];

			// add first point of current edge
			// 'new' is the one, created out of intersection, index of point on line ordered along the line is used in this case
			shapes[curInd].push({p: edge[0], i: i, new: false});
			const intInd = intersectionIndices.findIndex(x => x == i);
			if (intInd > -1) { // current edge is intersected
				const intersection = intersections[intInd];

				// intersection point can differ if the point was hacked
				let intrsH = hackedVerticesInds.indexOf(intersection.edge);
				const intrsP = intrsH > -1 ? hackedVertices[intrsH] : intersection.p; // intersection point

				// add intersection point to current shape
				shapes[curInd].push({p: intrsP, i: intInd, new: true});

				const iIndsOnlyNews = shapes[curInd].filter(x => x.new);
				if (iIndsOnlyNews.length < 2 // we've just started
					|| Math.abs(iIndsOnlyNews.at(0).i - iIndsOnlyNews.at(-1).i) > 1 // points on line r not adjacent
					|| Math.min(iIndsOnlyNews.at(0).i, iIndsOnlyNews.at(-1).i) % 2) // interval on line is ouside of main shape
					shapes.splice(++curInd, 0, []); // step into a new shape
				else
					curInd--; // step out of current shape

				shapes[curInd].push({p: intrsP, i: intInd, new: true});
			}
		}

		// filter out very small edges, that were created because of vertex&intersection hack
		shapes.forEach(shape => {
			for (let i = 0; i < shape.length; ++i) {
				const edge = [shape[i].p, shape[(i + 1) % shape.length].p];
				if (dst(edge[0], edge[1]) <= 3 * EPS)
					shape.splice(i--, 1);
			}
		});

		return shapes.map(sh => sh.map(x => x.p));
	}

	function calculateBestCut(shape) {
		// // first define cutting line
		// const [left, right, top, bottom] = getBBOX(shape);
		// // const p0 = [Math.random() * (right - left) + left, Math.random() * (bottom - top) + top];
		// const p0 = scale(SHAPE_SCALE, [1, 0.5]);
		// const ang0 = Math.random() * Math.PI;
		// const v0 = [Math.cos(ang0), Math.sin(ang0)];
		// // const p1 = [p0[0] + v0[0], p0[1] + v0[1]];
		// const p1 = scale(SHAPE_SCALE, [-7, 0.5]);

		ctx.save();
		ctx.translate(CNV_CENTER[0] - centerMass[0], CNV_CENTER[1] - centerMass[1]);
		drawLine(p0, p1, 'blue');
		ctx.restore();

		shapes = cutShapeWithLine(shape, [p0, p1]);

		console.log(shapes);
		shapes.forEach(sh => drawShape(sh, new CtxStyle(getRandomColor(), 5, 'connected'), false));
	}

	function simulateShapeFit(shape) {
		let shapeClone = shape.slice();
		// Test all rotations
		let bestFitAngle = 0, bestFitVal = Number.MAX_VALUE;
		for (let i = 0; i < Math.PI; i += SIMULATE_ANGLE_STEP) {
			let [left, right, top, bottom] = getBBOX(shapeClone);
			if (Math.max(right - left, bottom - top) < bestFitVal) {
				bestFitVal = Math.max(right - left, bottom - top);
				bestFitAngle = i;
			}
			rotateShape(shapeClone, SIMULATE_ANGLE_STEP, true);
		}
		return [bestFitAngle, bestFitVal];
	}

	function rotateShape(shape, ang, noCMCalc = false) {
		let s = Math.sin(ang);
		let c = Math.cos(ang);

		for (let i = 0; i < shape.length; i++) {
			let x = shape[i][0], y = shape[i][1];
			shape[i] = [x * c - y * s, x * s + y * c];
		}

		if (!noCMCalc)
			centerMass = getShapeCM(shape);
	}

	function drawLine(from, to, style, width) {
		ctx.save();

		ctx.beginPath();
		ctx.moveTo(from[0], from[1]);
		ctx.lineTo(to[0], to[1]);
		if (style)
			ctx.strokeStyle = style;
		if (width)
			ctx.lineWidth = width;
		ctx.stroke()

		ctx.restore();
	}
	function drawCircle(center, r, color, stroke=false, width=1) {
		ctx.save();

		ctx.beginPath();
		ctx.arc(center[0], center[1], r, 0, 2 * Math.PI);
		
		if (stroke) {
			ctx.strokeStyle = color;
			ctx.lineWidth = width;
			ctx.stroke()
		} else {
			ctx.fillStyle = color;
			ctx.fill();
		}

		ctx.restore();
	}
	function drawShape(shape, style=STYLE_SHAPE) {
		return drawPolygon(shape.concat([shape[0]]), style);
	}
	function drawPolygon(shape, style=STYLE_SHAPE) {
		if (shape.length < 1 || shape.includes(undefined))
			return;
		ctx.save();
		ctx.translate(CNV_CENTER[0] - centerMass[0], CNV_CENTER[1] - centerMass[1]);
		let clr = Array(shape.length).fill(style.color);
		if (style.color == 'gradient')
			for (let i = 0; i < shape.length; ++i)
				clr[i] = 'hsl(' + (i * 255 / (shape.length - 1)) + ',100%,50%)';
		if (style.type == 'connected')
			for (let i = 0; i < shape.length - 1; ++i)
				drawLine(shape[i], shape[i + 1], clr[i], style.width);
		else
			for (let i = 0; i < shape.length; ++i)
				drawCircle(shape[i], style.width, clr[i]);
		ctx.restore();
	}

	function redraw() {
		ctx.clearRect(0, 0, cnv.width, cnv.height);

		drawShape(pts, STYLE_SHAPE); // shape

		// const [l, r, t, b] = getBBOX(pts);
		// drawShape([[l, t], [l, b], [r, b], [r, t]], STYLE_BBOX); // bbox

		drawPolygon(pts, STYLE_POINTS); // points
	}
</script>
</body>
</html>